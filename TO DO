malloc, free	Pour construire dynamiquement les tokens, structures

printf	Pour debug/log pendant le parsing

write	√âventuellement pour des erreurs ou debug minimal

access	Pour v√©rifier si un fichier existe (utile en cas de redirection par exemple)

read	Possiblement utile pour heredoc

open, close	Idem : heredoc ou pour tester des fichiers

getenv	 Pour l expansion des variables d‚Äôenvironnement ($VAR)

strerror, perror	Afficher des erreurs li√©es au parsing, redirs




Ex√©cution de commandes simples et avec pipelines
Gestion des redirections (>, >>, <, <<)
Builtins (echo, cd, pwd, export, unset, env, exit)
Parsing avec gestion des quotes, variables d‚Äôenvironnement, etc.

üîπ Parsing & Tokenisation


Analyse lexicale (tokenisation de l'entr√©e utilisateur)
Gestion des quotes ('', "")
Expansion de variables ($VAR)
Cr√©ation d'une structure de commandes (t_simple_cmds)
Gestion des redirections et heredoc


üîπ Ex√©cution
Responsable : Bin√¥me

Ex√©cution des commandes simples
Gestion des pipelines
Mise en place des redirections
Appel des fonctions builtins
Gestion des processus et du parent/child split (fork, execve, wait...)
üóÇÔ∏è Arborescence

‚úÖ √âtape 1 : La structure partag√©e (t_data)
Voici une version document√©e de ta structure, √† partager dans un fichier commun :

üìÅ includes/shared_structs.h

#ifndef SHARED_STRUCTS_H
# define SHARED_STRUCTS_H

# include <stdbool.h>

/*
** Types de tokens (√† adapter selon ton tokenizer)
*/
typedef enum e_token_type
{
	T_WORD,
	T_PIPE,
	T_LESS,
	T_GREATER,
	T_DLESS,
	T_DGREATER
}	t_token_type;

/*
** Token = √©l√©ment lexical (commande, argument, op√©rateur, etc.)
*/
typedef struct s_token
{
	char			*str;
	t_token_type	type;
	struct s_token	*prev;
	struct s_token	*next;
}	t_token;

/*
** Commande = un maillon d‚Äôun pipeline
*/
typedef struct s_cmd
{
	bool			skip_cmd;     // Indique si cette commande doit √™tre ignor√©e (ex: && ou erreurs)
	int				infile;       // FD d‚Äôentr√©e (redirection "<" ou heredoc)
	int				outfile;      // FD de sortie (redirection ">" ou ">>")
	char			**cmd_param;  // Arguments de la commande (argv[])
	struct s_cmd	*prev;
	struct s_cmd	*next;
}	t_cmd;

/*
** Liste cha√Æn√©e simple (ex: pour l'environnement)
*/
typedef struct s_list
{
	char			*str;
	struct s_list	*prev;
	struct s_list	*next;
}	t_list;

/*
** Structure principale du shell ‚Äî utilis√©e par tout le monde
*/
typedef struct s_data
{
	t_list	*env;        // Environnement (envp format)
	t_token	*token;      // Liste des tokens bruts (produite par le lexer)
	t_cmd	*cmd;        // Liste des commandes (produite par le parser, utilis√©e par l'executor)
	int		exit_code;   // Code de sortie du shell (pour $? et suivi d‚Äô√©tat)
	int		pip[2];      // Pipe courant
	bool	sq;          // Quote simple ouverte ? (utile pendant le parsing)
}	t_data;

#endif




SINOOON 

#ifndef SHARED_STRUCTS_H
# define SHARED_STRUCTS_H

# include <stdbool.h>

typedef enum e_token_type
{
	T_WORD,
	T_PIPE,
	T_REDIR_IN,
	T_REDIR_OUT,
	T_REDIR_APPEND,
	T_HEREDOC
}	t_token_type;

typedef struct s_token
{
	char			*str;
	t_token_type	type;
	struct s_token	*next;
}	t_token;

typedef struct s_cmd
{
	char			**cmd_param;
	int				infile;
	int				outfile;
	struct s_cmd	*next;
}	t_cmd;

typedef struct s_list
{
	char			*str;
	struct s_list	*next;
}	t_list;

typedef struct s_data
{
	t_list	*env;
	t_token	*token;
	t_cmd	*cmd;
	int		exit_code;
}	t_data;

#endif


‚úÖ √âtape 2 : R√©partition du travail
Tu peux maintenant te mettre d‚Äôaccord avec ton bin√¥me :

üß© Toi (Parsing)
Tu √©cris les fonctions qui vont :

Lire l‚Äôentr√©e utilisateur

Faire une liste cha√Æn√©e de t_token

Transformer ces t_token en une liste de t_cmd

void lexer(t_data *data);
void parser(t_data *data);

√Ä la fin de ta partie, data->cmd est pr√™t √† √™tre ex√©cut√©.

‚öôÔ∏è Bin√¥me (Execution)
Elle s‚Äôoccupe de :

Lire data->cmd

G√©rer les redirections (infile, outfile)

Lancer les commandes avec fork, execve

G√©rer les pipes, exit_code, etc.

c
Copier
Modifier